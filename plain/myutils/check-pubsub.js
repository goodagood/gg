// Generated by CoffeeScript 1.8.0
(function() {
  var Promise, async, check_del_all, check_find_all_tasks, check_find_one, check_old_a, del_by_steps, del_key, filter_a, get_the_time, give_a_lock, milli_is_before, none_or_old_key, p, promised_show_by_id, pubsub, show_all_date, show_by_id, show_first_task_found, show_if_old, stop, try_lock, u;

  u = require("underscore");

  async = require("async");

  Promise = require("bluebird");

  pubsub = require("./pubsub.js");

  p = console.log;

  stop = function(period) {
    period = period || 500;
    return setTimeout(process.exit, 500);
  };

  check_find_all_tasks = function() {
    return pubsub.find_tasks(function(err, reply) {
      if (err) {
        p("Error in 'check find all tasks': ", err);
      }
      if (u.isArray(reply)) {
        p('is array');
      }
      p(reply);
      return stop();
    });
  };

  show_first_task_found = function() {
    return pubsub.find_tasks(function(err, reply) {
      var d1;
      if (err) {
        p("Error in 'check find all tasks': ", err);
      }
      p('show first 1: ', reply);
      d1 = reply[0];
      return pubsub.rclient.hgetall(d1, function(err, res) {
        p('show first 2 ', err, res);
        if (err) {
          p('error in "show first task found", hgetall');
        }
        if (res.lock != null) {
          p('result lock: ', res.lock);
          p('to date: ', new Date(res.lock));
        }
        return stop();
      });
    });
  };

  show_by_id = function(id, callback) {
    if (id == null) {
      return;
    }
    if (!callback) {
      callback = (function() {});
    }
    p('show by id: ', id);
    return pubsub.rclient.hgetall(id, function(err, data) {
      if (err) {
        p('error in "show by id", hgetall');
      }
      p('err, data:\n', err, data);
      return callback(err, data);
    });
  };

  promised_show_by_id = Promise.promisify(show_by_id);

  milli_is_before = function(milli_str, seconds) {
    var i, mark, now, period;
    now = Date.now();
    period = seconds * 1000;
    mark = now - period;
    i = parseInt(milli_str);
    if (i > mark) {
      return false;
    } else {
      return true;
    }
  };

  check_old_a = function() {
    var ep, five;
    five = 5 * 60 * 1000;
    ep = Date.now() - five;
    if (milli_is_before(ep, 301)) {
      p('is old');
    } else {
      p('new');
    }
    return stop();
  };

  show_all_date = function() {
    return pubsub.find_tasks(function(err, keys) {
      var show_key;
      if (err) {
        p("Error in 'check find all tasks': ", err);
      }
      show_key = function(key, callback) {
        return pubsub.rclient.hgetall(key, function(err, res) {
          var i;
          if (err) {
            p('error in "show first task found", hgetall');
          }
          p('name: ', res.name);
          if (res.lock != null) {
            p('result lock: ', res.lock);
            i = parseInt(res.lock);
            p('to date: ', new Date(i));
          } else {
            p('no lock');
          }
          return callback(err, res);
        });
      };
      return async.map(keys, show_key, function(err, results) {
        p('after map:');
        return stop();
      });
    });
  };

  show_if_old = function() {
    return pubsub.find_tasks(function(err, keys) {
      var show_key;
      if (err) {
        p("Error in 'check find all tasks': ", err);
      }
      show_key = function(key, callback) {
        return pubsub.rclient.hgetall(key, function(err, res) {
          var i;
          if (err) {
            p('error in "show first task found", hgetall');
          }
          if (res.lock != null) {
            if (milli_is_before(res.lock, 300)) {
              p('this is old, ');
            }
            i = parseInt(res.lock);
            p('to date: ', new Date(i));
          } else {
            p('no lock');
          }
          p('');
          return callback(err, res);
        });
      };
      return async.map(keys, show_key, function(err, results) {
        p('after map:');
        return stop();
      });
    });
  };

  none_or_old_key = function(key, callback) {
    var period;
    period = 300;
    return pubsub.rclient.hgetall(key, function(err, res) {
      if (err) {
        return callback(false);
      }
      if (res.lock != null) {
        if (milli_is_before(res.lock, period)) {
          return callback(true);
        }
      } else {
        return callback(true);
      }
    });
  };

  filter_a = function() {
    return pubsub.find_tasks(function(err, keys) {
      var count;
      if (err) {
        p("Error in 'check find all tasks': ", err);
      }
      count = 0;
      return async.filter(keys, none_or_old_key, function(results) {
        p('f1:\n', results);
        p('left:\n', u.difference(keys, results));
        return stop();
      });
    });
  };

  del_key = function(key, callback) {
    return pubsub.rclient.del(key, callback);
  };

  del_by_steps = function() {
    return pubsub.find_tasks(function(err, keys) {
      if (err) {
        return p("Error in 'del by steps': ", err);
      }
      return async.map(keys, del_key, function(err, results) {
        p('ds:\n', err, results);
        return stop();
      });
    });
  };

  check_del_all = function() {
    return pubsub.del_all_tasks(function(err, results) {
      p('check del all 1: \n', err, results);
      return stop();
    });
  };

  try_lock = function() {
    return pubsub.find_tasks(function(err, reply) {
      var d1;
      if (err) {
        p("Error in 'try lock': ", err);
      }
      p('show 1 try lock : ', reply);
      d1 = reply[0];
      return pubsub.rclient.hgetall(d1, function(err, res) {
        var id;
        id = res.id;
        if (id == null) {
          p('no id found');
          return stop();
        }
        return pubsub.add_task_lock(id, function(locked, unlock) {
          var promised_unlock;
          promised_unlock = Promise.promisify(unlock);
          if (locked) {
            return promised_show_by_id(id).then(function() {}).then(function() {
              p('show try lock 2 ', err, res);
              if (err) {
                p('error in "show try lock 3", hgetall');
              }
              if (res.lock != null) {
                p('result lock: ', res.lock);
                p('to date: ', new Date(res.lock));
              }
              return stop(11000);
            });
          }
        });
      });
    });
  };

  check_find_one = function(number) {
    number = number || 0;
    return pubsub.find_one_task(number, function(err, things) {
      p('check find ONE: ', err, things);
      return stop();
    });
  };

  give_a_lock = function() {
    return pubsub.find_one_task(0, function(err, one_job) {
      p('check find ONE: ', err, one_job);
      return pubsub.add_task_lock(one_job.id, function(locked, unlock) {
        if (locked) {
          p('locked? ', locked);
        }
        return stop();
      });
    });
  };

  get_the_time = function() {
    return pubsub.find_one_task(0, function(err, one_job) {
      return pubsub.find_lock_time(one_job.id, function(err, time, a, b, c) {
        p('check the time: ', err, time, a, b, c);
        return stop();
      });
    });
  };

  check_del_all();

}).call(this);
