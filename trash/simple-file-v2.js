// Generated by CoffeeScript 1.8.0
(function() {
  var Promise, bucket, fix_file_meta, ft, myconfig, myutil, new_plain_file, old, p, pass_meta_to_task, path, promise_to_make_old_simple_file_object, promised_new_plain_file, promised_simple_s3_file_obj, put_local_file, put_local_file_without_pass, simple_s3_file_obj, stop, task, test_file_name, test_folder_name, test_json_file_name, test_owner_name, u, write_a_text_file, write_text_file;

  u = require("underscore");

  Promise = require("bluebird");

  path = require("path");

  old = require("./simple-file.js");

  bucket = require("./bucket.js");

  myutil = require('../myutils/myutil.js');

  myconfig =  require("../config/config.js");

  task = require('../myutils/job.js');

  ft = require('../myutils/filetype.js');

  p = console.log;

  promise_to_make_old_simple_file_object = Promise.promisify(old.simple_s3_file_obj);

  simple_s3_file_obj = function(meta_src, pass_file_obj) {
    var Meta, Obj, calculate_meta_defaults, convert_meta_to_ul, get_saved_meta, guess_owner, increase_value, isError, read_file_to_buffer, read_to_string, save_meta_file, set_meta, _build_ul, _keep;
    Meta = null;
    Obj = null;
    set_meta = function(_meta) {
      return Meta = _meta;
    };
    isError = function() {
      return Meta.error;
    };
    guess_owner = function() {
      var guess;
      if (typeof Meta.owner === "string" || /^\s*$/.test(Meta.owner)) {
        return Meta.owner;
      }
      if (Meta.path) {
        guess = Meta.path.split("/")[0];
        if (typeof guess === "string" || /^\s*$/.test(guess)) {
          Meta.owner = guess;
          Meta.owner;
        }
      } else {
        guess = null;
      }
      return guess;
    };
    calculate_meta_defaults = function() {
      var necessaries, parent_dir, uuid_name;
      if (typeof Meta.filetype !== "string") {
        Meta.filetype = ft.check_file_type_by_name(Meta.name);
      }
      if (typeof Meta.s3_stream_href !== "string") {
        Meta.s3_stream_href = _calculate_s3_stream_href();
      }
      if (typeof Meta.delete_href !== "string") {
        Meta.delete_href = _calculate_delete_href();
      }
      if (typeof Meta.view_href !== "string") {
        Meta.view_href = _calculate_view_href();
      }
      if (!Meta.uuid) {
        Meta.uuid = myutil.get_uuid();
      }
      if (typeof Meta.owner !== "string") {
        guess_owner();
      }
      if (typeof Meta.uuid_path === "undefined") {
        uuid_name = Meta.uuid + path.extname(Meta.name);
        parent_dir = path.dirname(Meta.path);
        Meta.uuid_path = path.join(parent_dir, uuid_name);
      }
      necessaries = {
        what: myconfig.IamFile,
        timestamp: Date.now(),
        permission: {
          owner: "rwx",
          group: "",
          other: ""
        },
        "file-types": [],
        storage: {},
        storages: [],
        html: {},
        value: {
          amount: 0,
          unit: "GG"
        }
      };
      return u.defaults(Meta, necessaries);
    };
    read_file_to_buffer = function(callback) {
      if (meta.storage.type !== "s3") {
        return callback(null);
      }
      return bucket.read_data(meta.storage.key, callback);
    };
    read_to_string = function(callback) {
      return bucket.read_to_string(meta.storage.key, callback);
    };
    _keep = function(hash, names) {
      var name, _i, _len, _meta;
      if (u.isEmpty(names)) {
        return hash;
      }
      _meta = {};
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        _meta[name] = hash[name];
      }
      return _meta;
    };
    _build_ul = function(hash) {
      var ul;
      ul = "<ul> \n";
      u.each(hash, function(val, key) {
        var li;
        li = '<li class="key"> <span>' + key.toString() + "</span> : ";
        if (u.isArray(val)) {
          li += _build_ul(val);
        } else if (u.isObject(val)) {
          li += _build_ul(val);
        } else if (!val) {
          li += '<span class="value">' + (" " + val + " </span>");
        } else {
          li += '<span class="value">' + val.toString() + '</span>';
        }
        li += "</li>\n";
        return ul += li + "\n";
      });
      ul += "</ul>\n";
      return ul;
    };
    convert_meta_to_ul = function() {
      var attr_names, _show_meta;
      attr_names = ['name', 'path', 'owner', 'uuid', 'timestamp', 'size', 'permission'];
      _show_meta = _keep(Meta, attr_names);
      return _build_ul(_show_meta);
    };
    increase_value = function(amount) {
      if (!amount) {
        amount = 1;
      }
      return Meta.value.amount += amount;
    };
    save_meta_file = function(callback) {
      var Meta_s3key;
      Meta_s3key = path.join(myconfig.file_meta_prefix, Meta.owner, Meta.uuid);
      Meta.Meta_s3key = Meta_s3key;
      return bucket.write_json(Meta_s3key, Meta, callback);
    };
    get_saved_meta = function(callback) {
      return bucket.read_json(Meta_s3key, callback);
    };
    return old.simple_s3_file_obj(meta_src, function(err, _obj) {
      if (!err) {
        Meta = _obj.get_meta();
        Obj = _obj;
      } else {
        return callback(err, _obj);
      }
      if (Obj === null) {
        err = 'empty object after "old.simple s3 file obj"?';
      }
      Obj.convert_meta_to_ul = convert_meta_to_ul;
      Obj.read_to_string = read_to_string;
      Obj.read_file_to_buffer = read_file_to_buffer;
      Obj.set_meta = set_meta;
      Obj.calculate_meta_defaults = calculate_meta_defaults;
      Obj.increase_value = increase_value;
      Obj.save_meta_file = save_meta_file;
      Obj.get_saved_meta = get_saved_meta;
      return pass_file_obj(err, Obj);
    });
  };

  promised_simple_s3_file_obj = Promise.promisify(simple_s3_file_obj);

  new_plain_file = function(text, meta, callback) {
    var s3key;
    fix_file_meta(meta);
    s3key = meta.storage.key;
    return bucket.write_text_file(s3key, text, function(err, aws_result) {
      return pass_meta_to_task(meta, callback);
    });
  };

  promised_new_plain_file = Promise.promisify(new_plain_file);

  put_local_file = function(local_file_path, meta, callback) {
    var s3key;
    fix_file_meta(meta);
    s3key = meta.storage.key;
    return bucket.put_one_file(local_file_path, s3key, function(err, aws_result) {
      return pass_meta_to_task(meta, callback);
    });
  };

  put_local_file_without_pass = function(local_file_path, meta, callback) {
    var s3key;
    fix_file_meta(meta);
    s3key = meta.storage.key;
    return bucket.put_one_file(local_file_path, s3key, function(err, aws_result) {
      return callback(err, meta);
    });
  };

  fix_file_meta = function(_meta) {
    if (_meta.name == null) {
      return false;
    }
    if (_meta.path == null) {
      return false;
    }
    if (!_meta.owner) {
      return false;
    }
    if (_meta.dir == null) {
      _meta.dir = path.dirname(_meta.path);
    }
    if (_meta.timestamp == null) {
      _meta.timestamp = Date.now();
    }
    if (_meta.uuid == null) {
      _meta.uuid = myutil.get_uuid();
    }
    _meta.meta_s3key = path.join(myconfig.new_meta_prefix, _meta.dir, _meta.uuid);
    _meta.initial_key = _meta.meta_s3key;
    _meta.s3key = path.join(myconfig.raw_file_prefix, _meta.dir, _meta.uuid);
    _meta.storage = {
      type: 's3',
      key: _meta.s3key
    };
    return _meta;
  };

  pass_meta_to_task = function(meta, callback) {
    var job;
    job = {
      name: 'new-file-meta',
      task_name: 'new-file-meta',
      username: meta.owner,
      folder: meta.dir,
      meta_s3key: meta.meta_s3key
    };
    return bucket.write_json(meta.meta_s3key, meta, function(err, reply) {
      if (err) {
        log28('write file meta to s3 ERR', [meta.meta_s3key, meta]);
        return callback(err, null);
      }
      return task.pub_task(task.channel, job, callback);
    });
  };

  write_text_file = function(owner, dir, filename, text) {
    var file_meta, m;
    file_meta = {
      name: filename,
      path: path.join(dir, filename),
      owner: owner,
      size: text.length
    };
    m = fix_file_meta(file_meta);
    return promised_new_plain_file(text, m);
  };

  module.exports.simple_s3_file_obj = simple_s3_file_obj;

  module.exports.promised_simple_s3_file_obj = promised_simple_s3_file_obj;

  module.exports.new_file_obj_from_meta = old.new_file_obj_from_meta;

  module.exports.fix_file_meta = fix_file_meta;

  module.exports.new_plain_file = new_plain_file;

  module.exports.promised_new_plain_file = promised_new_plain_file;

  module.exports.write_text_file = write_text_file;

  module.exports.put_local_file = put_local_file;

  module.exports.put_local_file_without_pass = put_local_file_without_pass;

  p = console.log;

  stop = function() {
    return setTimeout(process.exit, 500);
  };

  test_owner_name = 'abc';

  test_folder_name = 'abc';

  test_json_file_name = 'test.json';

  test_file_name = 'check04';

  write_a_text_file = function() {
    var F, dir, name, owner, text;
    owner = test_owner_name;
    dir = test_folder_name;
    name = test_file_name;
    text = "\nI am checking\na new plain\nfile\n";
    F = null;
    return write_text_file(owner, dir, name, text).then(function(what) {
      return p('what: ', what);
    }).then(stop);
  };

  if (require.main === module) {
    write_a_text_file();
  }

}).call(this);
