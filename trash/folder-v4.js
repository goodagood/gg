// Generated by CoffeeScript 1.8.0
(function() {
  var Promise, async, bucket, build_new_folder, build_new_folder_and_save, init_home_folder_11_15, make_s3folder_v4, make_s3folder_v4a, meta, myconfig, obj, old, p, path, promised_make_s3folder, promised_retrieve_file_obj, promised_retrieve_folder, ready, retrieve_file_obj, s3file, u, _folder_css_file_name, _get_file_obj_by_uuid, _get_file_objs_by_name, _get_uuids, _meta_css_file_name, _modify_folder_object, _read_file, _uuid_to_file_obj, _write_text_file;

  u = require("underscore");

  Promise = require("bluebird");

  path = require("path");

  async = require("async");

  bucket = require('./bucket.js');

  s3file = require("./simple-file-v1.js");

  myconfig =  require("../config/config.js");

  old = require("./folder-v1.js");

  p = console.log;

  promised_make_s3folder = Promise.promisify(old.make_s3folder);

  promised_retrieve_folder = Promise.promisify(old.retrieve_folder);

  meta = {};

  obj = {};

  ready = 0;

  _folder_css_file_name = ".gg.folder.css";

  _meta_css_file_name = ".gg.meta.css";

  make_s3folder_v4 = function(folder_path, callback) {
    return promised_retrieve_folder(folder_path).then(function(folder) {
      _modify_folder_object(folder);
      meta = folder.get_meta();
      obj = folder;
      ready = 1;
      return obj;
    })["catch"](function(err) {
      throw err;
    });
  };

  _modify_folder_object = function(_obj) {
    _obj.get_file_obj_by_uuid = _get_file_obj_by_uuid;
    _obj.get_file_objs_by_name = _get_file_objs_by_name;
    _obj.get_uuids = _get_uuids;
    _obj.read_file_by_name = _read_file;
    _obj.read_text_file = _read_file;
    return _obj.write_text_file = _write_text_file;
  };

  _read_file = function(filename) {
    if (ready < 1) {
      throw 'global objects must be ready.';
    }
    return new Promise(function(resolve, reject) {
      return obj.get_file_objs_by_name(filename, function(err, objs) {
        var file;
        if (objs.length >= 1) {
          file = objs[0];
          return file.read_to_string(function(str) {
            return resolve(str);
          });
        } else {
          return reject(err);
        }
      });
    });
  };

  _write_text_file = function(filename, text) {
    var file_meta, m;
    if (ready < 1) {
      throw 'global objects must be ready.';
    }
    file_meta = {
      name: filename,
      path: path.join(meta.path, filename),
      size: text.length,
      owner: meta.owner
    };
    m = s3file.fix_file_meta(file_meta);
    return new Promise(function(resolve, reject) {
      return s3file.new_plain_file(text, m, function(err, what) {
        if (err) {
          return reject(err);
        } else {
          return resolve(what);
        }
      });
    });
  };

  _get_file_obj_by_uuid = function(uuid) {
    var file_meta;
    if (ready < 1) {
      throw 'global objects must be ready: obj, meta, ready';
    }
    if (!meta.files[uuid]) {
      throw "no such uuid in meta.files " + uuid;
    }
    file_meta = meta.files[uuid];
    return s3file.promised_simple_s3_file_obj(file_meta).then(function(file_obj) {
      return file_obj;
    });
  };

  _uuid_to_file_obj = function(uuid, callback) {
    var file_meta;
    file_meta = meta.files[uuid];
    return s3file.simple_s3_file_obj(file_meta, callback);
  };

  _get_uuids = function(name) {
    var uuid_list;
    uuid_list = meta.file_names[name];
    return uuid_list;
  };

  _get_file_objs_by_name = function(name, callback) {
    var uuid_list;
    if (ready < 1) {
      throw 'global objects must be ready: obj, meta, ready';
    }
    uuid_list = _get_uuids(name);
    if (!uuid_list) {
      throw "no file found by " + name;
    }
    return async.map(uuid_list, _uuid_to_file_obj, callback);
  };

  retrieve_file_obj = function(file_path, callback) {
    var filename, folder_path;
    folder_path = path.dirname(file_path);
    filename = path.basename(file_path);
    return make_s3folder_v4(folder_path).then(function(folder) {
      return folder.get_file_objs_by_name(filename, function(err, objs) {
        if (objs.length >= 1) {
          return callback(err, objs[0]);
        } else {
          return callback(err, null);
        }
      });
    });
  };

  promised_retrieve_file_obj = function(file_path, callback) {
    var filename, folder_path;
    folder_path = path.dirname(file_path);
    filename = path.basename(file_path);
    return make_s3folder_v4(folder_path).then(function(folder) {
      return new Promise(resolve, reject)(function() {
        return folder.get_file_objs_by_name(filename, function(err, objs) {
          if (objs.length >= 1) {
            return resolve(objs[0]);
          } else {
            return reject(err);
          }
        });
      });
    });
  };

  make_s3folder_v4a = function(folder_path, callback) {
    var build_fun, clear_empty_names, delete_file, delete_file_by_uuid, delete_name, dir, get_file_obj_by_uuid, get_file_objs_by_name, get_uuids, list_files_and_save, modify_folder_object, promise_to_clear_empty_names, promise_to_delete_uuid, promise_to_list_files_and_save, read_file, read_file_by_uuid, read_files, uuid_to_file_obj, write_text_file, _del_uuid_and_name, _empty_promise, _folder_css_file_name_, _meta_, _meta_css_file_name_, _obj_, _ready_, _short_clone_of_folder_meta, _sleep;
    _meta_ = {};
    _obj_ = {};
    _ready_ = 0;
    _folder_css_file_name_ = ".gg.folder.css";
    _meta_css_file_name_ = ".gg.meta.css";
    read_file = function(filename) {
      if (_ready_ < 1) {
        throw 'global objects must be _ready_.';
      }
      return new Promise(function(resolve, reject) {
        return get_file_objs_by_name(filename, function(err, objs) {
          var file;
          if (objs.length >= 1) {
            file = objs[0];
            return file.read_to_string(function(str) {
              return resolve(str);
            });
          } else {
            return reject(err);
          }
        });
      });
    };
    read_files = function(filename) {
      if (_ready_ < 1) {
        throw 'global objects must be _ready_.';
      }
      return new Promise(function(resolve, reject) {
        return get_file_objs_by_name(filename, function(err, objs) {
          var read_one;
          read_one = function(file_obj, callback) {
            return file_obj.read_to_string(function(str) {
              if (str) {
                return callback(null, str);
              } else {
                return callback('err happen?', null);
              }
            });
          };
          return async.map(objs, read_one, function(err, file_contents) {
            if (err) {
              return reject(err);
            } else {
              return resolve(file_contents);
            }
          });
        });
      });
    };
    read_file_by_uuid = function(uuid) {
      if (_ready_ < 1) {
        throw 'global objects must be _ready_.';
      }
      p('read file here');
      return get_file_obj_by_uuid(uuid).then(function(file) {
        return new Promise(function(resolve) {
          return file.read_to_string(function(str) {
            return resolve(str);
          });
        });
      });
    };
    write_text_file = function(filename, text) {
      var file_meta, m;
      if (_ready_ < 1) {
        throw 'global objects must be _ready_.';
      }
      file_meta = {
        name: filename,
        path: path.join(_meta_.path, filename),
        size: text.length,
        owner: _meta_.owner
      };
      m = s3file.fix_file_meta(file_meta);
      return new Promise(function(resolve, reject) {
        return s3file.new_plain_file(text, m, function(err, what) {
          if (err) {
            return reject(err);
          } else {
            return resolve(what);
          }
        });
      });
    };
    get_file_obj_by_uuid = function(uuid) {
      var file_meta;
      if (_ready_ < 1) {
        throw 'global objects must be ready: _obj_, _meta_, _ready_';
      }
      if (!_meta_.files[uuid]) {
        throw "no such uuid in _meta_.files " + uuid;
      }
      file_meta = _meta_.files[uuid];
      return s3file.promised_simple_s3_file_obj(file_meta).then(function(file_obj) {
        return file_obj;
      });
    };
    uuid_to_file_obj = function(uuid, callback) {
      var file_meta;
      file_meta = _meta_.files[uuid];
      return s3file.simple_s3_file_obj(file_meta, callback);
    };
    get_uuids = function(name) {
      var uuid_list;
      uuid_list = _meta_.file_names[name];
      return uuid_list;
    };
    get_file_objs_by_name = function(name, callback) {
      var uuid_list;
      if (_ready_ < 1) {
        throw 'global objects must be ready: obj, _meta_, ready';
      }
      uuid_list = get_uuids(name);
      if (!uuid_list) {
        throw "no file found by " + name;
      }
      return async.map(uuid_list, uuid_to_file_obj, callback);
    };
    _del_uuid_and_name = function(uuid, name) {
      var file_meta, fn, idx;
      file_meta = _meta_.files[uuid];
      name = name || file_meta.name;
      p('-- in del uuid and ... ', name);
      if (_meta_.files[uuid]) {
        delete _meta_.files[uuid];
      }
      delete _meta_.file_uuids[uuid];
      delete _meta_.files[uuid];
      fn = _meta_.file_names[name];
      if (!fn) {
        return;
      }
      idx = fn.indexOf(uuid);
      p("fn, idx: ", fn, idx);
      if (idx != null) {
        fn.splice(idx, 1);
      }
      if (fn.length < 1) {
        return delete _meta_.file_names[name];
      }
    };
    delete_file_by_uuid = function(uuid, callback) {
      get_file_obj_by_uuid(uuid).then(function(obj) {
        return obj.delete_s3_storage();
      });
      _del_uuid_and_name(uuid);
      return _obj_.build_file_list(function() {
        return _obj_.save_meta(callback);
      });
    };
    promise_to_delete_uuid = Promise.promisify(delete_file_by_uuid);
    _sleep = function(seconds) {
      seconds = seconds || 1;
      return new Promise(function(resolve) {
        return setTimeout(resolve, seconds * 1000);
      });
    };
    _empty_promise = new Promise(function(resolve, reject) {});
    delete_name = function(name) {
      var id, r, uuids;
      uuids = _meta_.file_names[name];
      if ((uuids == null) || !uuids || u.isEmpty(uuids || uuids.length === 0)) {
        return _empty_promise;
      }
      while (uuids.length > 0) {
        id = uuids[0];
        r = promise_to_delete_uuid(id).then(function() {
          return _sleep();
        })["catch"](function(err) {});
      }
      return r;
    };
    clear_empty_names = function() {
      var key, uuids, _i, _len, _ref;
      p(Object.keys(_meta_.file_names));
      _ref = Object.keys(_meta_.file_names);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        p('here: ', key);
        uuids = _meta_.file_names[key];
        p("del key: " + key + " get uuids: ", uuids);
        if ((uuids == null) || !uuids || u.isEmpty(uuids || uuids.length === 0)) {
          p('try to delete: ', key);
          delete _meta_.file_names[key];
        }
      }
      return _obj_.build_file_list(function() {
        return _obj_.save_meta(callback);
      });
    };
    promise_to_clear_empty_names = Promise.promisify(clear_empty_names);
    build_fun = function(uuid) {
      var fun;
      fun = function(callback) {
        if (callback == null) {
          callback = function() {};
        }
        p('going to delete one.');
        return delete_file_by_uuid(uuid, callback);
      };
      return fun;
    };
    delete_file = function(name, callback) {
      var funs, uuids;
      uuids = _meta_.file_names[name];
      if (!uuids) {
        return callback("get no uuids for " + name, null);
      }
      if (uuids.length == null) {
        return callback("uuids has no 'length' for " + name, null);
      }
      funs = uuids.map(build_fun);
      return async.series(funs, callback);
    };
    list_files_and_save = function(callback) {
      return _obj_.build_file_list(function() {
        return _obj_.save_meta(function(err, meta) {
          return callback(err, home_folder);
        });
      });
    };
    promise_to_list_files_and_save = Promise.promisify(list_files_and_save);
    _short_clone_of_folder_meta = function(input_meta) {
      var out_meta, to_delete;
      to_delete = ['files', 'file_uuids', 'file_names', 'renders'];
      out_meta = JSON.parse(JSON.stringify(input_meta));
      to_delete.forEach(function(n) {
        return delete out_meta[n];
      });
      return out_meta;
    };
    modify_folder_object = function(obj) {
      obj.get_file_obj_by_uuid = get_file_obj_by_uuid;
      obj.get_file_objs_by_name = get_file_objs_by_name;
      obj.get_uuids = get_uuids;
      obj.read_file_by_name = read_file;
      obj.read_files_by_name = read_files;
      obj.read_file_by_uuid = read_file_by_uuid;
      obj.delete_file = delete_file;
      obj.delete_name = delete_name;
      obj.delete_file_by_uuid = delete_file_by_uuid;
      obj.promise_to_delete_uuid = promise_to_delete_uuid;
      obj.read_text_file = read_file;
      obj.write_text_file = write_text_file;
      obj.clear_empty_names = clear_empty_names;
      obj.promise_to_clear_empty_names = promise_to_clear_empty_names;
      return obj.promise_to_list_files_and_save = promise_to_list_files_and_save;
    };
    dir = null;
    return promised_retrieve_folder(folder_path).then(function(folder) {
      modify_folder_object(folder);
      _obj_ = folder;
      _meta_ = folder.get_meta();
      _ready_ = 1;
      return _obj_;
    }).then(function(_obj_) {
      var members;
      members = require("./members.js");
      dir = path.dirname(_meta_.path);
      _obj_.members_obj = members.make_members_obj(dir);
      return _obj_;
    });
  };

  build_new_folder_and_save = function(opt, callback) {
    return make_s3folder_v4a(opt.path).then(function(folder) {
      folder.init(opt);
      return folder;
    }).then(function(folder) {
      folder.self_render_as_a_file();
      return folder;
    });
  };

  build_new_folder = function(opt, callback) {
    return make_s3folder_v4a(opt.path).then(function(folder) {
      folder.init(opt);
      return folder;
    });
  };

  init_home_folder_11_15 = function(username) {
    var Goodagood, Home, folder_opt, s3key;
    s3key = path.join(myconfig.meta_file_prefix, username);
    folder_opt = {};
    folder_opt['path'] = username;
    folder_opt['name'] = username;
    folder_opt['parent-dir'] = '';
    folder_opt.owner = username;
    folder_opt.permission = {
      owner: 'rwx',
      other: '',
      group: ''
    };
    folder_opt['create-timestamp'] = Date.now();
    folder_opt['timestamp'] = Date.now();
    Home = null;
    Goodagood = null;
    return build_new_folder(folder_opt).then(function(folder) {
      p(1);
      Home = folder;
      return Home.promised_add_folder('goodagood');
    }).then(function(g) {
      var gm;
      p(2);
      Goodagood = g;
      gm = g.get_meta();
      p('goodagood meta: ', gm);
      return Goodagood.promised_add_folder('message');
    }).then(function(msg) {
      p(3);
      p('msg obj: ', Object.keys(msg).sort());
      return Goodagood.promised_add_folder('etc');
    }).then(function() {
      return Goodagood.promise_to_list_files_and_save();
    }).then(function() {
      return Home.promised_add_folder('public');
    }).then(function() {
      return Home.promise_to_list_files_and_save();
    });
  };

  module.exports.old = old;

  module.exports.make_s3folder_v4 = make_s3folder_v4;

  module.exports.make_s3folder_v4a = make_s3folder_v4a;

  module.exports.retrieve_file_obj = retrieve_file_obj;

  module.exports.init_home_folder_11_15 = init_home_folder_11_15;

  module.exports.build_new_folder_and_save = build_new_folder_and_save;

  module.exports.make_s3folder = old.make_s3folder;

  module.exports.get_file_meta_by_path = old.get_file_meta_by_path;

  module.exports.retrieve_folder = old.retrieve_folder;

  module.exports.retrieve_folder_meta = old.retrieve_folder_meta;

  module.exports.retrieve_file_meta = old.retrieve_file_meta;

  module.exports.delete_file = old.delete_file;

  module.exports.get_sorted_message_list_as_ul = old.get_sorted_message_list_as_ul;

  module.exports.init_home_folder = old.init_home_folder;

  module.exports.init_home_folder_0927 = old.init_home_folder_0927;

  module.exports.get_file_uuid = old.get_file_uuid;

  module.exports.get_file_meta_by_uuid = old.get_file_meta_by_uuid;

}).call(this);
